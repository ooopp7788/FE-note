### 初始化过程

#### createElement(type, config, children or …child[])
> react/ReactElement.js
```TS
function ReactElement() {
    return {
        $$typeof: REACT_ELEMENT_TYPE, // Symbol

        type: type,
        key: key,
        ref: ref,
        props: props,

        _owner: owner,
    };
}
```

#### render
> react/ReactDomLegacy.js
```TS
function render(
  element: React$Element<any>,
  container: DOMContainer, // dom 元素
  callback: ?Function,
) {
  return legacyRenderSubtreeIntoContainer(
    null,
    element,
    container,
    false,
    callback,
  );
}
```

#### legacyRenderSubtreeIntoContainer
> react/ReactLegacy.js
1. `legacyCreateRootFromDOMContainer` 初始化 `ReactDOMBlockingRoot` 实例作为 container
2. `ReactDOMBlockingRoot` 构造函数会调用 `createFiberRoot`
3. `updateContainer` 更新视图

```TS
function legacyRenderSubtreeIntoContainer(
  parentComponent: ?React$Component<any, any>,
  children: ReactNodeList,
  container: DOMContainer,
  forceHydrate: boolean,
  callback: ?Function,
) {
  let root: RootType = (container._reactRootContainer: any);
  let fiberRoot;
  if (!root) {
    // 初始化, _reactRootContainer: ReactDOMBlockingRoot 实例
    // root = new ReactDOMBlockingRoot(ReactDOMBlockingRoot): {
    //     _internalRoot: new FiberRoot().current = new FiberNode(),
    //     render: () => ...,
    //     unmount: () => ...,
    // }
    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(
      container,
      forceHydrate,
    );

    fiberRoot = root._internalRoot;
    if (typeof callback === 'function') {
      const originalCallback = callback;
      callback = function() {
        const instance = getPublicRootInstance(fiberRoot);
        originalCallback.call(instance);
      };
    }
    // Initial mount should not be batched.
    // 初次更新
    unbatchedUpdates(() => {
      updateContainer(children, fiberRoot, parentComponent, callback);
    });
  } else {
    fiberRoot = root._internalRoot;
    if (typeof callback === 'function') {
      const originalCallback = callback;
      callback = function() {
        const instance = getPublicRootInstance(fiberRoot);
        originalCallback.call(instance);
      };
    }
    // Update
    updateContainer(children, fiberRoot, parentComponent, callback);
  }
  return getPublicRootInstance(fiberRoot);
}
```

#### createFiberRoot
> react-reconciler/ReactFiberRoot.js
1. 实例化 `root = new FiberRootNode(...)`
2. `createHostRootFiber()` 返回 `uninitializedFiber: FiberNode` 实例
3. `initializeUpdateQueue` 将 `uninitializedFiber.updateQueue` 更新队列初始化
```TS
function createFiberRoot(
  containerInfo: any,
  tag: RootTag,
  hydrate: boolean,
  hydrationCallbacks: null | SuspenseHydrationCallbacks,
): FiberRoot {
    // 初始化 FiberRootNode 实例
  const root: FiberRoot = (new FiberRootNode(containerInfo, tag, hydrate): any);

  const uninitializedFiber = createHostRootFiber(tag); // 返回 FiberNode 实例
  root.current = uninitializedFiber;
  uninitializedFiber.stateNode = root;

//   const queue: UpdateQueue<State> = {
//     baseState: fiber.memoizedState,
//     baseQueue: null,
//     shared: {
//       pending: null,
//     },
//     effects: null,
//   };
//   fiber.updateQueue = queue;
  initializeUpdateQueue(uninitializedFiber); // 初始化实例的 更新的队列 updateQueue
  return root;
}
```



#### updateContainer
> react-reconciler/ReactFiberReconciler.js

```TS
function updateContainer(
  element: ReactNodeList, // children
  container: OpaqueRoot, // FiberRoot
  parentComponent: ?React$Component<any, any>,
  callback: ?Function,
): ExpirationTime {
    const current = container.current; // 当前 fiber 节点
    const currentTime = requestCurrentTimeForUpdate();

    const suspenseConfig = requestCurrentSuspenseConfig();
    const expirationTime = computeExpirationForFiber( // 计算当前 fiber 过期时间
        currentTime,
        current,
        suspenseConfig,
    );

    const context = getContextForSubtree(parentComponent);
    if (container.context === null) {
        container.context = context;
    } else {
        container.pendingContext = context;
    }

//   let update: Update<*> = {
//     expirationTime,
//     suspenseConfig,

//     tag: UpdateState,
//     payload: null,
//     callback: null,

//     next: (null: any),
//   };
//   创建新的 update, 会被插入 UpdateQueue
    const update = createUpdate(expirationTime, suspenseConfig);

    update.payload = {element};

    callback = callback === undefined ? null : callback;
    if (callback !== null) {
        update.callback = callback;
    }

    enqueueUpdate(current, update); // 将 update 插入到 fiber.updateQueue 中
    scheduleWork(current, expirationTime);

    return expirationTime;
}
```

> ReactUpdateQueue.js
```ts
export function enqueueUpdate<State>(fiber: Fiber, update: Update<State>) {
  const updateQueue = fiber.updateQueue;

  const sharedQueue = updateQueue.shared;
  const pending = sharedQueue.pending; // 链表
  if (pending === null) {
    // This is the first update. Create a circular list.
    update.next = update;
  } else {
    // 在 pending 和 pending.next 中间插入 update
    update.next = pending.next;
    pending.next = update;
  }
  sharedQueue.pending = update;
}
```
> ReactFiberWorkLoop.js
```ts
// scheduleWork
export function scheduleUpdateOnFiber(
  fiber: Fiber,
  expirationTime: ExpirationTime,
) {
  checkForNestedUpdates();
  warnAboutInvalidUpdatesOnClassComponentsInDEV(fiber);

  const root = markUpdateTimeFromFiberToRoot(fiber, expirationTime); // ?
  if (root === null) {
    warnAboutUpdateOnUnmountedFiberInDEV(fiber);
    return;
  }

  checkForInterruption(fiber, expirationTime); // 是否中断当前任务
  recordScheduleUpdate();

  // TODO: computeExpirationForFiber also reads the priority. Pass the
  // priority as an argument to that function and this one.
  const priorityLevel = getCurrentPriorityLevel();

  if (expirationTime === Sync) {
    if (
      // Check if we're inside unbatchedUpdates
      (executionContext & LegacyUnbatchedContext) !== NoContext &&
      // Check if we're not already rendering
      (executionContext & (RenderContext | CommitContext)) === NoContext
    ) {
      // Register pending interactions on the root to avoid losing traced interaction data.
      schedulePendingInteractions(root, expirationTime);

      // This is a legacy edge case. The initial mount of a ReactDOM.render-ed
      // root inside of batchedUpdates should be synchronous, but layout updates
      // should be deferred until the end of the batch.
      performSyncWorkOnRoot(root);
    } else {
      ensureRootIsScheduled(root);
      schedulePendingInteractions(root, expirationTime);
      if (executionContext === NoContext) {
        // Flush the synchronous work now, unless we're already working or inside
        // a batch. This is intentionally inside scheduleUpdateOnFiber instead of
        // scheduleCallbackForFiber to preserve the ability to schedule a callback
        // without immediately flushing it. We only do this for user-initiated
        // updates, to preserve historical behavior of legacy mode.
        flushSyncCallbackQueue();
      }
    }
  } else {
    ensureRootIsScheduled(root);
    schedulePendingInteractions(root, expirationTime);
  }

  if (
    (executionContext & DiscreteEventContext) !== NoContext &&
    // Only updates at user-blocking priority or greater are considered
    // discrete, even inside a discrete event.
    (priorityLevel === UserBlockingPriority ||
      priorityLevel === ImmediatePriority)
  ) {
    // This is the result of a discrete event. Track the lowest priority
    // discrete update per root so we can flush them early, if needed.
    if (rootsWithPendingDiscreteUpdates === null) {
      rootsWithPendingDiscreteUpdates = new Map([[root, expirationTime]]);
    } else {
      const lastDiscreteTime = rootsWithPendingDiscreteUpdates.get(root);
      if (lastDiscreteTime === undefined || lastDiscreteTime > expirationTime) {
        rootsWithPendingDiscreteUpdates.set(root, expirationTime);
      }
    }
  }
}
```

### 更新策略
1.
