### 初始化过程

#### createElement(type, config, children or …child[])
> react/ReactElement.js
```TS
function ReactElement() {
    return {
        $$typeof: REACT_ELEMENT_TYPE, // Symbol

        type: type,
        key: key,
        ref: ref,
        props: props,

        _owner: owner,
    };
}
```

#### render
> react/ReactDomLegacy.js
```TS
function render(
  element: React$Element<any>,
  container: DOMContainer,
  callback: ?Function,
) {
  return legacyRenderSubtreeIntoContainer(
    null,
    element,
    container,
    false,
    callback,
  );
}
```

#### legacyRenderSubtreeIntoContainer
> react/ReactElement.js
1. `legacyCreateRootFromDOMContainer` 初始化 `ReactDOMBlockingRoot` 实例作为 container
2. `ReactDOMBlockingRoot` 构造函数会调用 `createFiberRoot`
3. `updateContainer` 更新视图

```TS
function legacyRenderSubtreeIntoContainer(
  parentComponent: ?React$Component<any, any>,
  children: ReactNodeList,
  container: DOMContainer,
  forceHydrate: boolean,
  callback: ?Function,
) {
  let root: RootType = (container._reactRootContainer: any);
  let fiberRoot;
  if (!root) {
    // 初始化, _reactRootContainer: ReactDOMBlockingRoot 实例
    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(
      container,
      forceHydrate,
    );
    fiberRoot = root._internalRoot;
    if (typeof callback === 'function') {
      const originalCallback = callback;
      callback = function() {
        const instance = getPublicRootInstance(fiberRoot);
        originalCallback.call(instance);
      };
    }
    // Initial mount should not be batched.
    // 初次更新
    unbatchedUpdates(() => {
      updateContainer(children, fiberRoot, parentComponent, callback);
    });
  } else {
    fiberRoot = root._internalRoot;
    if (typeof callback === 'function') {
      const originalCallback = callback;
      callback = function() {
        const instance = getPublicRootInstance(fiberRoot);
        originalCallback.call(instance);
      };
    }
    // Update
    updateContainer(children, fiberRoot, parentComponent, callback);
  }
  return getPublicRootInstance(fiberRoot);
}
```

#### createFiberRoot
> react-reconciler/ReactFiberRoot.js
1. 实例化 `root = new FiberRootNode(...)`
2. `createHostRootFiber()` 返回 `uninitializedFiber: FiberNode` 实例
3. `initializeUpdateQueue` 将 `uninitializedFiber.updateQueue` 更新队列初始化
```TS
function createFiberRoot(
  containerInfo: any,
  tag: RootTag,
  hydrate: boolean,
  hydrationCallbacks: null | SuspenseHydrationCallbacks,
): FiberRoot {
    // 初始化 FiberRootNode 实例
  const root: FiberRoot = (new FiberRootNode(containerInfo, tag, hydrate): any);

  const uninitializedFiber = createHostRootFiber(tag); // 返回 FiberNode 实例
  root.current = uninitializedFiber;
  uninitializedFiber.stateNode = root;

//   const queue: UpdateQueue<State> = {
//     baseState: fiber.memoizedState,
//     baseQueue: null,
//     shared: {
//       pending: null,
//     },
//     effects: null,
//   };
//   fiber.updateQueue = queue;
  initializeUpdateQueue(uninitializedFiber); // 初始化实例的 更新的队列 updateQueue
  return root;
}
```



#### updateContainer
> react-reconciler/ReactFiberReconciler.js

```TS
function updateContainer(
  element: ReactNodeList,
  container: OpaqueRoot,
  parentComponent: ?React$Component<any, any>,
  callback: ?Function,
): ExpirationTime {
    const current = container.current;
    const currentTime = requestCurrentTimeForUpdate();

    const suspenseConfig = requestCurrentSuspenseConfig();
    const expirationTime = computeExpirationForFiber(
        currentTime,
        current,
        suspenseConfig,
    );

    const context = getContextForSubtree(parentComponent);
    if (container.context === null) {
        container.context = context;
    } else {
        container.pendingContext = context;
    }

    const update = createUpdate(expirationTime, suspenseConfig);

    update.payload = {element};

    callback = callback === undefined ? null : callback;
    if (callback !== null) {
        update.callback = callback;
    }

    enqueueUpdate(current, update);
    scheduleWork(current, expirationTime);

    return expirationTime;
}
```


### 更新策略
1.
