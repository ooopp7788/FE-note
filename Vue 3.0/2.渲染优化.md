### 渲染优化

#### runtime: @runtime-core
闭包变量
- shouldTrack = 1 默认值为1
- currentBlock: 当前block
- blockStack: block 栈

相关方法, 部分方法会在编译期注入调用代码
- setBlockTracking: 编译时产生调用代码
- createBlock: 创建 block 时停止tracking, 防止 tracking 到 block
		shouldTrack - -; // 防止自己被 tracking 
		createVNode(); // 仅创建当前 block 的 vnode, 不递归 children
		shouldTrack ++;
		vnode.dynamicChildren = currentBlock; // 收集好的 currentBlock 储存在 vnode.dynamicChildren: VNode[]
- createVNode: 递归创建 VNode, 同时收集 VNode 下的普通(静态?) VNode 后代节点
		使用 shouldTrack > 0 等联合条件判断是否需要 patch
		currentBlock.push(vnode); //  shouldTrack > 0 时, push 到 currentBlock, 收集静态节点
	openBlock: 创建一个新的 block: [], 并 push 到 blockStack
	
	例子: 一个 render 函数
	function () {
		return ( _openBlock(),
			_createBlock(
				"template",
				null,
				[
					_createVNode("div", { class: "container" },
					[name
						? (_openBlock(),_createBlock("span", { key: 0, class: "name" }, _toDisplayString(name), 1 /* TEXT */))
                        				: _createCommentVNode("v-if", true),
                        			_createVNode("span", { class: "static" }, _toDisplayString(age), 1 /* TEXT */)])
                			]
            		)
        		)
	}
执行过程为
- _openBlock(), 创建 outBlock
- 调用 _createBlock 前, _createBlock 参数求值
- 参数求值时, 会调用 createVNode , 此时静态 VNode 会被收集到 currentBlock
- 求值时根据 v-if name 判断,  调用内部 _openBlock(), _createBlock(…) 或 _createCommentVNode(…)
- 调用 _createVNode(“div”, …), 依赖收集到 currentBlock
- 最后调用 外部 _createBlock, 内部会创建 VNode
- 创建 VNode 前 shouldTrack - - 暂停收集到自身 VNode
- VNode.dynamicChildren = currentBlock; 将依赖存储在 VNode 上
- 静态 VNode 收集完毕
*备注: v-if v-for 这种动态节点也会创建 block, 所以在递归创建这些 VNode 时都被 block 所包裹不会被外层收集到, 也符合预期, 仅仅收集静态 VNode


问题: 何为静态VNode？
	在编译期会决定, 具体代码在 compile/codegen.ts 里
	大概是 v-if v-for 相关 vnode 是动态的, 其他的都是静态 vnode, patch时直接按顺序patch dynamicChildren


compile: @compile-core

compile.ts: 
	baseParse(template, options) // 生成ast
	transform(ast, options)
	generate(ast, options)

parse.ts: ast 生成
	baseParse

transform.ts: 
	createRootCodegen(root, context)


codegen.ts: 将 ast 加工为 render function 字符串
	generate: 
		创建context: 包括 helper 等函数, 以及生成的代码 code 存储
		genNode(ast.codegenNode, context) // 递归生成 code , 包括 cache 优化代码, context.code 中储存
		
		case NodeTypes.JS_CACHE_EXPRESSION:

			genCacheExpression: 递归生成 render code, 并插入优化代码
				helper(SET_BLOCK_TRACKING)(-1)
				genNode(…) // 生成 node 代码
				helper(SET_BLOCK_TRACKING)(1)


