### 渲染优化

#### runtime: @runtime-core

>闭包变量
- shouldTrack = 1 默认值是 1, 表示所有 VNode 默认都会 track 后代节点
- currentBlock: 当前block
- blockStack: block 栈

>相关方法, 部分方法会在编译期注入调用代码
- setBlockTracking: 编译时产生调用代码
- createBlock: 创建 block 时停止tracking, 防止 tracking 到 block
- createVNode: 创建 VNode, 同时收集 VNode 下的普通(静态?) VNode 后代节点
- openBlock: 创建一个新的 block: [], 并 push 到 blockStack

>代码示例
```TypeScript
// 模板
`
<template>
    <div class="container">
        <span class="name" v-if="name">{{name}}</span>
        <span class="static">{{ age }}</span>
    </div>
</template>
`
// @vue/compiler-core baseCompiler 编译后的 render 函数
function render() {
    return (
        _openBlock(),
        _createBlock(
            "template",
            null,
            [
                _createVNode(
                    "div",
                    { class: "container" },
                    [
                        name
                        ? (_openBlock(), _createBlock("span", { key: 0, class: "name" }, _toDisplayString(name), 1 /* TEXT */))
                        : _createCommentVNode("v-if", true),
                        _createVNode("span", { class: "static" }, _toDisplayString(age), 1 /* TEXT */)
                    ]
                )
            ]
        )
    )
}
```

分析具体执行过程
- _openBlock(), 创建 outBlock
- 调用 _createBlock 前, _createBlock 参数求值
- 参数求值时, 会调用 createVNode , 此时静态 VNode 会被收集到 currentBlock
- 求值时根据 v-if name 判断,  调用内部 _openBlock(), _createBlock(...) 或 _createCommentVNode(...)
- 调用 _createVNode("div", ...), 依赖收集到 currentBlock
- 最后调用 外部 _createBlock, 内部会创建 VNode
- 创建 VNode 前 shouldTrack - - 暂停收集到自身 VNode
- VNode.dynamicChildren = currentBlock; 将依赖存储在 VNode 上
- 静态 VNode 收集完毕
*备注: v-if v-for 这种动态节点也会创建 block, 所以在递归创建这些 VNode 时都被 block 所包裹不会被外层收集到, 也符合预期, 仅仅收集静态 VNode

```TypeScript
function createBlock(
  type: VNodeTypes | ClassComponent,
  props?: { [key: string]: any } | null,
  children?: any,
  patchFlag?: number,
  dynamicProps?: string[]
): VNode {
  // avoid a block with patchFlag tracking itself
  shouldTrack-- // 防止自己被自己 tracking
  const vnode = createVNode(type, props, children, patchFlag, dynamicProps) // 仅创建当前 block 的 vnode, 不递归 children
  shouldTrack++
  // save current block children on the block vnode
  vnode.dynamicChildren = currentBlock || EMPTY_ARR // 收集好的 currentBlock 储存在 vnode.dynamicChildren: VNode[]
  // close block
  blockStack.pop()
  currentBlock = blockStack[blockStack.length - 1] || null
  // a block is always going to be patched, so track it as a child of its
  // parent block
  if (currentBlock !== null) {
    currentBlock.push(vnode)
  }
  return vnode
}

function createVNode() {
    // ... 创建 VNode 实例 省略
    // shouldTrack > 0 时才可能收集 vnode (还会过滤一些必须全量递归patch的情况)
    if (
        shouldTrack > 0
        && currentBlock !== null
        // && otherStatus // 其他情况, 略
    ) {
        currentBlock.push(vnode) // 收集当前 vnode
    }
}
```


#### compile: @compile-core

#### compile.ts
1. baseParse(template, options) // 生成ast
2. transform(ast, options)
3. generate(ast, options)

#### codegen.ts: 将 ast 加工为 render function 字符串
generate:
1. 创建context: 包括 helper, push 等函数, 以及生成的代码 code 存储
2. genNode(ast.codegenNode, context) -> genCacheExpression() 递归生成 code , 包括 cache 优化代码, context.code 中储存
3. 注入代码 helper(SET_BLOCK_TRACKING)(-1); genNode(...); helper(SET_BLOCK_TRACKING)(1)

```TypeScript
function generate() {
    const context = createCodegenContext(ast, options)
    const { push, indent, newLine } = context;
    // 拼接固定代码, 比如 import 
    push(`function render(_ctx, _cache) {`)
    // ...
    push(`with (_ctx) {`)
    // ...
    // components, assets, directives, 等等代码生成
    push(`return `)
    // 递归生成 code, 包括 cache block 优化代码, 同样放在 context.code 中储存
    genNode(ast.codegenNode, context)
}

```

#### 总结
1. 第一阶段是 compile 阶段, 会根据 ast 节点类型, 判断是否做渲染优化, 将除了 v-if v-for 以外的节点都当做 block 处理, block 节点在 compile 生成 render 函数时, 会采用 `openBlock` 和 `createBlock` 包裹, 而 v-if 和 v-for 节点会包装一些防止 tracking 的代码
2. 第二阶段是 runtime 首次渲染阶段, 在 render 函数执行时, 如果是 VNode 创建时, 会动态的 tracking 后代节点中的 block 节点, 并存储在 VNode.dynamicChildren 中
3. 第三阶段是 runtime patch 阶段, 在 patch 时, 在对 dynamicChildren 不为空的 VNode 节点做 patch 时, 由于 dynamicChildren 都是静态节点, 不会产生顺序的变化, 所以直接按顺序 `patch(oldChildren[i], newChildren[i])` 省去递归 VNode 树的过程

#### TODO
1. v-if v-for render 函数分析
2. compile 源码分析